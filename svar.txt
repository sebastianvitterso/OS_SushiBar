======================================== Svar p친 oppgaver: ========================================
a. obj.wait() lar en vente p친 obj's monitor, imens obj.notify og obj.notifyAll vil 
vekke de som venter p친 obj's monitor. 
Forskjellen mellom notify og notifyAll er at notify vekker kun 칠n som waiter 
(dersom det er fler, er det relativt tilfeldig hvilken som vekkes), imens notifyAll
vekker alle som waiter p친 ressursen.  

b. WaitingArea.customers og de tre SynchronizedIntegerene i SushiBar er delte ressurser som
m친 manages. De siste managet seg selv vha. SynchronizedInteger-klassen, imens customers m친tte 
manuelt styres. Dette ble gjort ved 친 legge synchronized-flagget p친 alle interaksjoner med 
ressursen, for 친 gj칮re operasjonene atomiske.

c. SushiBar skriver ut de siste statistikkene etter alle andre threads er ferdige/selvterminerte, 
ved 친 vente p친 thread.join()-er. Dermed vil den skrive statistikken til slutt, n친r alle er ferdige
med dem, og alle kunder er dratt hjem mette og gode. 游녧游꼮
===================================================================================================


====================================== Generell beskrivelse: ======================================
Totalt sett implementeres SushiBaren som et monitor-system ved at Door (producer) og Waitress 
(consumer) begge henter forholder seg til monitoren til WaitingArea. For den snacksy delen av 
implementasjonen, se Door.java:38 og Waitress.java:39. Disse to stedene bruker jeg 
waitingArea.wait(), som skal avbrytes av henholdsvis WaitingArea.java:42 og WaitingArea.java:25. 
Door venter n친r waitingArea er fullt, og "vekkes" n친r en kunde hentes fra waitingArea (alts친 er 
ikke WA full lenger), imens Waitress venter n친r WA er tomt, og "vekkes" n친r en kunde legges inn i 
WA (alts친 er ikke WA tomt lenger). 
===================================================================================================
